<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D FPS Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 24px;
            text-align: center;
            cursor: pointer;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>Simple FPS</h1>
        <p>Click to start</p>
        <p>
            W, A, S, D: Move<br>
            SPACE: Jump<br>
            MOUSE: Look<br>
            CLICK: Shoot
        </p>
    </div>
    <div id="crosshair" style="display: none;"></div>
    <div id="score" style="display: none;">Score: 0</div>
    <canvas id="game-canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, controls;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let onGround = false;
        let score = 0;

        const objects = [];
        const targets = [];
        const moveForward = { value: false };
        const moveBackward = { value: false };
        const moveLeft = { value: false };
        const moveRight = { value: false };
        const canJump = { value: false };

        const instructions = document.getElementById('instructions');
        const crosshair = document.getElementById('crosshair');
        const scoreElement = document.getElementById('score');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.8;

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            // Controls
            controls = new PointerLockControls(camera, document.body);
            instructions.addEventListener('click', () => {
                controls.lock();
            });
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                crosshair.style.display = 'block';
                scoreElement.style.display = 'block';
            });
            controls.addEventListener('unlock', () => {
                instructions.style.display = 'flex';
                crosshair.style.display = 'none';
                scoreElement.style.display = 'none';
            });
            scene.add(controls.getObject());

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            objects.push(floor);

            // Walls
            const wallGeometry = new THREE.BoxGeometry(100, 5, 1);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const wall1 = new THREE.Mesh(wallGeometry, wallMaterial);
            wall1.position.set(0, 2.5, -50);
            wall1.castShadow = true;
            wall1.receiveShadow = true;
            scene.add(wall1);
            objects.push(wall1);

            const wall2 = wall1.clone();
            wall2.position.z = 50;
            scene.add(wall2);
            objects.push(wall2);

            const wall3 = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 100), wallMaterial);
            wall3.position.set(-50, 2.5, 0);
            wall3.castShadow = true;
            wall3.receiveShadow = true;
            scene.add(wall3);
            objects.push(wall3);

            const wall4 = wall3.clone();
            wall4.position.x = 50;
            scene.add(wall4);
            objects.push(wall4);


            // Targets
            const targetGeometry = new THREE.BoxGeometry(1, 1, 1);
            for (let i = 0; i < 20; i++) {
                const targetMaterial = new THREE.MeshStandardMaterial({ color: new THREE.Color(Math.random(), Math.random(), Math.random()) });
                const target = new THREE.Mesh(targetGeometry, targetMaterial);
                target.position.set(
                    Math.random() * 80 - 40,
                    Math.random() * 3 + 1,
                    Math.random() * 80 - 40
                );
                target.castShadow = true;
                target.receiveShadow = true;
                scene.add(target);
                objects.push(target);
                targets.push(target);
            }

            // Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', shoot);
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward.value = true; break;
                case 'KeyA': moveLeft.value = true; break;
                case 'KeyS': moveBackward.value = true; break;
                case 'KeyD': moveRight.value = true; break;
                case 'Space': if (canJump.value) velocity.y += 8; canJump.value = false; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward.value = false; break;
                case 'KeyA': moveLeft.value = false; break;
                case 'KeyS': moveBackward.value = false; break;
                case 'KeyD': moveRight.value = false; break;
            }
        }

        function shoot() {
            if (!controls.isLocked) return;

            const raycaster = new THREE.Raycaster(camera.getWorldPosition(new THREE.Vector3()), camera.getWorldDirection(new THREE.Vector3()));
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                scene.remove(intersectedObject);
                
                const index = targets.indexOf(intersectedObject);
                if (index > -1) {
                    targets.splice(index, 1);
                }
                const objIndex = objects.indexOf(intersectedObject);
                 if (objIndex > -1) {
                    objects.splice(objIndex, 1);
                }

                score++;
                scoreElement.textContent = `Score: ${score}`;

                if (targets.length === 0) {
                    alert("You win!");
                    controls.unlock();
                }
            }
        }

        let prevTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                // Gravity
                velocity.y -= 9.8 * delta;

                // Movement
                direction.z = Number(moveForward.value) - Number(moveBackward.value);
                direction.x = Number(moveRight.value) - Number(moveLeft.value);
                direction.normalize();

                const speed = 40.0;
                if (moveForward.value || moveBackward.value) velocity.z -= direction.z * speed * delta;
                if (moveLeft.value || moveRight.value) velocity.x -= direction.x * speed * delta;
                
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += velocity.y * delta;

                // Damping
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                // Ground check
                if (controls.getObject().position.y < 1.8) {
                    velocity.y = 0;
                    controls.getObject().position.y = 1.8;
                    canJump.value = true;
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
